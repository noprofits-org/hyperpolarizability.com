<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Hyperpolarizability.com - Fundamentals of Quantum Chemistry I (DRAFT)</title>
        <link rel="stylesheet" href="../css/default.css" />
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../js/mathjax-config.js"></script>
        <script src="../js/code-copy.js"></script>
        <script src="../js/print.js"></script>
    </head>
    <body>
        <header>
            <div class="header-content">
                <div class="logo">
                    <a href="../">Hyperpolarizability.com</a>
                </div>
                <nav>
                    <a href="../">Home</a>
                    <a href="../about.html">About</a>
                    <a href="../contact.html">Contact</a>
                    <a href="../archive.html">Archive</a>
                </nav>
            </div>
        </header>

        <main role="main">
            <div class="container">
                <h1>Fundamentals of Quantum Chemistry I (DRAFT)</h1>
                <article>
    <section class="header">
        Posted on April 22, 2025
        
        by Peter Johnston
        
    </section>
    
    <section>
        <h1 id="introduction">Introduction</h1>
<p>Quantum chemistry represents one of the most significant intersections of theoretical physics and computational science in modern chemistry. By applying quantum mechanical principles to molecular systems, researchers can predict chemical properties, reaction mechanisms, and molecular behavior with remarkable accuracy. This work demonstrates fundamental quantum mechanical concepts through computational implementation, bridging theoretical foundations with practical applications.</p>
<p>The quantum mechanical description of chemical systems begins with the Schrödinger equation, which determines how the wavefunction of a quantum system evolves. While the mathematical complexity of this equation limits analytical solutions to only the simplest systems, these foundational models provide critical insights into the quantum nature of matter. The particle in a box, quantum harmonic oscillator, and hydrogen atom models explored in this work serve as cornerstones for understanding more complex molecular systems.</p>
<p>Modern quantum chemistry depends heavily on computational methods to extend these principles to systems of practical interest. The development of efficient algorithms, specialized software packages, and high-performance computing resources has transformed quantum chemistry from a purely theoretical discipline to an applied science with broad impacts across chemistry, materials science, and biochemistry. The computational implementations presented here demonstrate how theoretical principles can be translated into numerical approaches accessible to researchers without specialized hardware.</p>
<p>This integration of theory and computation offers several advantages. First, it provides a framework for visualizing quantum mechanical phenomena that are inherently abstract and counter-intuitive. The probability distributions, orbital shapes, and uncertainty relationships demonstrated in this work help build physical intuition about quantum systems. Second, it establishes a foundation for understanding more sophisticated computational chemistry methods used in research and industry. Finally, it exemplifies how open-source scientific software enables reproducible, transparent research in computational chemistry.</p>
<p>The methods demonstrated in this work emphasize fundamental principles rather than computational efficiency. For research applications involving larger molecular systems, more sophisticated approaches such as density functional theory, post-Hartree-Fock methods, or machine learning models would typically be employed. However, understanding these foundational concepts and their implementation remains essential for interpreting results from more complex methods.</p>
<p>By exploring these quantum mechanical systems through both mathematical formalism and computational implementation, this work provides a comprehensive introduction to quantum chemistry principles. The following sections detail the mathematical frameworks underlying these concepts, the programming techniques used for implementation, and the results that emerge from these models, offering insights into the quantum mechanical behavior of chemical systems at the atomic and molecular scale.</p>
<h2 id="mathematical-frameworks">Mathematical Frameworks</h2>
<p>Quantum chemistry builds upon the fundamental postulates of quantum mechanics to describe the behavior of particles at the atomic and molecular scale. The experiments in this work demonstrate several core quantum mechanical principles.</p>
<h3 id="wavefunctions-and-the-schrödinger-equation">Wavefunctions and the Schrödinger Equation</h3>
<p>The cornerstone of quantum mechanics is the time-independent Schrödinger equation:</p>
<p><span class="math display">\[-\frac{\hbar^2}{2m}\frac{d^2\psi}{dx^2} + V(x)\psi = E\psi \tag{1}\]</span></p>
<p>This equation determines the wavefunction <span class="math inline">\(\psi(x)\)</span> of a quantum system, where <span class="math inline">\(\hbar\)</span> is the reduced Planck constant, <span class="math inline">\(m\)</span> is the particle mass, <span class="math inline">\(V(x)\)</span> is the potential energy function, and <span class="math inline">\(E\)</span> is the total energy. The wavefunction contains all obtainable information about the quantum system.</p>
<p>According to the Born interpretation, the probability of finding a particle in an infinitesimal region <span class="math inline">\(dx\)</span> at position <span class="math inline">\(x\)</span> is proportional to <span class="math inline">\(|\psi(x)|^2 dx\)</span>. For a normalized wavefunction:</p>
<p><span class="math display">\[\int_{-\infty}^{\infty} |\psi(x)|^2 dx = 1 \tag{2}\]</span></p>
<h3 id="particle-in-a-box">Particle in a Box</h3>
<p>For a particle confined to a one-dimensional box of length <span class="math inline">\(L\)</span> (where <span class="math inline">\(V(x) = 0\)</span> for <span class="math inline">\(0 &lt; x &lt; L\)</span> and <span class="math inline">\(V(x) = \infty\)</span> elsewhere), the normalized wavefunctions are:</p>
<p><span class="math display">\[\psi_n(x) = \sqrt{\frac{2}{L}}\sin\left(\frac{n\pi x}{L}\right) \tag{3}\]</span></p>
<p>with corresponding energy eigenvalues:</p>
<p><span class="math display">\[E_n = \frac{n^2\pi^2\hbar^2}{2mL^2} \tag{4}\]</span></p>
<p>where <span class="math inline">\(n = 1, 2, 3, \ldots\)</span> is the quantum number. This simple model demonstrates energy quantization, where only discrete energy values are allowed.</p>
<h3 id="quantum-harmonic-oscillator">Quantum Harmonic Oscillator</h3>
<p>The quantum harmonic oscillator represents a particle in a parabolic potential <span class="math inline">\(V(x) = \frac{1}{2}m\omega^2 x^2\)</span>, where <span class="math inline">\(\omega\)</span> is the angular frequency. The normalized wavefunctions are:</p>
<p><span class="math display">\[\psi_n(x) = \left(\frac{\alpha}{\sqrt{\pi}2^n n!}\right)^{1/2} H_n(\alpha x) e^{-\alpha^2 x^2/2} \tag{5}\]</span></p>
<p>where <span class="math inline">\(\alpha = \sqrt{m\omega/\hbar}\)</span>, and <span class="math inline">\(H_n\)</span> represents the Hermite polynomial of order <span class="math inline">\(n\)</span>. The corresponding energy eigenvalues are:</p>
<p><span class="math display">\[E_n = \hbar\omega\left(n + \frac{1}{2}\right) \tag{6}\]</span></p>
<p>This model is crucial for understanding molecular vibrations and illustrates the zero-point energy (<span class="math inline">\(E_0 = \frac{1}{2}\hbar\omega\)</span>) that exists even in the ground state.</p>
<h3 id="hydrogen-atom">Hydrogen Atom</h3>
<p>The hydrogen atom represents the simplest real atomic system. For the three-dimensional hydrogen atom, the Schrödinger equation in spherical coordinates is:</p>
<p><span class="math display">\[-\frac{\hbar^2}{2m}\nabla^2\psi + V(r)\psi = E\psi\]</span></p>
<p>where <span class="math inline">\(V(r) = -\frac{e^2}{4\pi\epsilon_0 r}\)</span> for the hydrogen atom.</p>
<p>For the ground state (1s orbital), the normalized wavefunction is:</p>
<p><span class="math display">\[\psi_{100}(r) = \frac{1}{\sqrt{\pi}}\left(\frac{Z}{a_0}\right)^{3/2}e^{-Zr/a_0} \tag{7}\]</span></p>
<p>where <span class="math inline">\(Z\)</span> is the nuclear charge (1 for hydrogen) and <span class="math inline">\(a_0\)</span> is the Bohr radius (approximately 0.529 Å). The radial probability density function is given by:</p>
<p><span class="math display">\[P(r) = 4\pi r^2 |R_{1s}(r)|^2 \tag{8}\]</span></p>
<p>where <span class="math inline">\(R_{1s}(r) = 2\left(\frac{Z}{a_0}\right)^{3/2}e^{-Zr/a_0}\)</span> is the radial part of the wavefunction. This function represents the probability of finding the electron at distance <span class="math inline">\(r\)</span> from the nucleus.</p>
<h3 id="expectation-values-and-uncertainty">Expectation Values and Uncertainty</h3>
<p>The expectation value of an observable <span class="math inline">\(A\)</span> is calculated as:</p>
<p><span class="math display">\[\langle A \rangle = \int \psi^* \hat{A} \psi dx \tag{9}\]</span></p>
<p>where <span class="math inline">\(\hat{A}\)</span> is the operator corresponding to <span class="math inline">\(A\)</span>. For position and position-squared:</p>
<p><span class="math display">\[\langle x \rangle = \int \psi^* x \psi dx \tag{10}\]</span>
<span class="math display">\[\langle x^2 \rangle = \int \psi^* x^2 \psi dx \tag{11}\]</span></p>
<p>For the hydrogen atom in spherical coordinates, these integrals become:</p>
<p><span class="math display">\[\langle r \rangle = \int_0^{\infty} 4\pi r^2 |\psi(r)|^2 r dr\]</span></p>
<p>The uncertainty in position is then given by:</p>
<p><span class="math display">\[\Delta x = \sqrt{\langle x^2 \rangle - \langle x \rangle^2} \tag{12}\]</span></p>
<h3 id="heisenberg-uncertainty-principle">Heisenberg Uncertainty Principle</h3>
<p>The Heisenberg uncertainty principle states that for position and momentum:</p>
<p><span class="math display">\[\Delta x \cdot \Delta p \geq \frac{\hbar}{2} \tag{13}\]</span></p>
<p>This fundamental limitation is demonstrated using Gaussian wavepackets where:</p>
<p><span class="math display">\[\psi(x) = \left(\frac{1}{2\pi\sigma^2}\right)^{1/4}e^{-x^2/4\sigma^2} \tag{14}\]</span></p>
<p>For these wavepackets, <span class="math inline">\(\Delta x = \sigma\sqrt{2}\)</span> and <span class="math inline">\(\Delta p = \frac{\hbar}{2\sigma}\sqrt{2}\)</span>, yielding <span class="math inline">\(\Delta x \cdot \Delta p = \frac{\hbar}{2}\)</span>, satisfying the uncertainty relation at the minimum possible value.</p>
<h2 id="programming-techniques">Programming Techniques</h2>
<p>This work employs a variety of Python libraries and programming techniques to implement quantum mechanical calculations. By utilizing open-source scientific computing packages, we’re able to model complex quantum systems with relatively simple code structures.</p>
<h3 id="core-scientific-libraries">Core Scientific Libraries</h3>
<p>Our quantum chemistry calculations rely on several fundamental scientific Python packages. NumPy provides the foundation for numerical computations through its efficient array operations and mathematical functions.<span class="citation" data-cites="harris2020array"><sup>1</sup></span> All our wavefunctions are represented as NumPy arrays, allowing for vectorized operations that significantly improve computational efficiency compared to explicit loops.</p>
<p>SciPy extends NumPy’s functionality with specialized scientific routines.<span class="citation" data-cites="2020SciPy-NMeth"><sup>2</sup></span> We specifically leverage SciPy’s constants module for physical constants (e.g., Planck’s constant, electron mass) and the special module for accessing mathematical functions like Hermite polynomials used in harmonic oscillator calculations.</p>
<p>Matplotlib serves as our primary visualization tool.<span class="citation" data-cites="Hunter2007"><sup>3</sup></span> We use it to create publication-quality figures that illustrate wavefunctions, probability densities, and orbital visualizations.</p>
<h3 id="quantum-chemistry-package">Quantum Chemistry Package</h3>
<p>For electronic structure calculations, we employ Psi4, an open-source quantum chemistry package with Python API integration.<span class="citation" data-cites="Smith2020"><sup>4</sup></span> Psi4 provides computational methods for solving quantum mechanical equations for atomic and molecular systems. In our hydrogen atom simulation, we use Psi4 to configure the computational environment, define molecular geometries, perform self-consistent field (SCF) calculations, and extract energy values and electronic structure information.</p>
<h3 id="numerical-methods">Numerical Methods</h3>
<p>Several computational techniques are employed across our simulations. Numerical integration is used to calculate expectation values like ⟨x⟩ and ⟨x²⟩ from wavefunctions. We implement this using discrete summation with appropriate step sizes. For example, computing the expectation value for position is accomplished through summation across the wavefunction multiplied by position and integrated over space.</p>
<p>Eigenvalue problems are solved implicitly in our simulations. While we use analytical solutions for the particle in a box and harmonic oscillator, Psi4 internally solves matrix eigenvalue problems to obtain molecular orbitals and energies.</p>
<p>Normalization is applied to ensure wavefunctions satisfy the condition that ∫|ψ|²dx = 1, maintaining proper probabilistic interpretation. For instance, the particle in a box wavefunction is normalized through the square root of 2/L coefficient applied to the sine function.</p>
<h3 id="visualization-techniques">Visualization Techniques</h3>
<p>Our code employs several visualization approaches. Function plotting with Matplotlib displays wavefunctions and probability densities. Contour plots visualize orbital distributions in 2D space. We use combined plots that show both wavefunctions and energy levels simultaneously. Filled plots enhance visualization of probability distributions.</p>
<h3 id="environment-configuration">Environment Configuration</h3>
<p>All calculations were performed in a dedicated Conda environment configured specifically for quantum chemistry.<span class="citation" data-cites="Conda2016"><sup>5</sup></span> This environment manages package dependencies and ensures reproducibility across different systems. Key features of our computational environment include Python 3.9 compatibility (required for Psi4), isolated dependency management, and consistent versioning of scientific packages. The precise system specifications are provided in Table 1.</p>
<h1 id="experimental">Experimental</h1>
<h2 id="system-configuration">System Configuration</h2>
<p><strong>Table 1.</strong> System specifications of the target computer used for environment setup, showing distribution details, hardware specifications, and available resources. The system offers adequate CPU, memory, and storage resources for computational chemistry applications.</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td>Distribution</td>
<td>Ubuntu 24.04.2 LTS (Noble)</td>
</tr>
<tr>
<td>Kernel</td>
<td>Linux 6.11.0-21-generic</td>
</tr>
<tr>
<td>Architecture</td>
<td>x86_64 (64-bit)</td>
</tr>
<tr>
<td>CPU</td>
<td>11th Gen Intel Core i7-1165G7 @ 2.80GHz</td>
</tr>
<tr>
<td>CPU Cores</td>
<td>4 cores, 8 threads (Hyperthreading enabled)</td>
</tr>
<tr>
<td>CPU Max Frequency</td>
<td>4.7 GHz</td>
</tr>
<tr>
<td>Memory</td>
<td>16GB RAM (15.9GB total)</td>
</tr>
<tr>
<td>Swap</td>
<td>4GB</td>
</tr>
<tr>
<td>Storage</td>
<td>954GB NVMe SSD (937GB available)</td>
</tr>
<tr>
<td>Graphics</td>
<td>Intel Iris Xe Graphics</td>
</tr>
</tbody>
</table>
<strong>Code 1.</strong> Python implementation of the particle in a box model, demonstrating wavefunction calculation, energy level quantization, and probability density visualization. Includes computation of position expectation values and uncertainties for the first three quantum states.
<details>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> constants</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Use a built-in Matplotlib style</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up the box parameters</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># box length in nm</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>n_states <span class="op">=</span> <span class="dv">3</span>  <span class="co"># number of energy states to calculate</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>n_points <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># points for plotting</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, L, n_points)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Constants</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>h_bar <span class="op">=</span> constants.hbar</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>m_e <span class="op">=</span> constants.m_e</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>eV <span class="op">=</span> constants.electron_volt</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Create wavefunctions and energies</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>wavefunctions <span class="op">=</span> []</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>energies <span class="op">=</span> []</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>energies_eV <span class="op">=</span> []</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_states <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> np.sqrt(<span class="dv">2</span><span class="op">/</span>L) <span class="op">*</span> np.sin(n <span class="op">*</span> np.pi <span class="op">*</span> x <span class="op">/</span> L)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    wavefunctions.append(psi)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    L_m <span class="op">=</span> L <span class="op">*</span> <span class="fl">1e-9</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    E <span class="op">=</span> (n<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.pi<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> h_bar<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> m_e <span class="op">*</span> L_m<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    energies.append(E)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    E_eV <span class="op">=</span> E <span class="op">/</span> eV</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    energies_eV.append(E_eV)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify normalization</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_states <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> wavefunctions[n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    integral <span class="op">=</span> np.<span class="bu">sum</span>(psi<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> (L<span class="op">/</span>n_points)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Wavefunction n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> normalization: </span><span class="sc">{</span>integral<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 1: Wavefunctions with Energy Levels</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> plt.cm.tab10(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, n_states))  <span class="co"># Distinct colors</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale wavefunction for visibility</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    plt.plot(x, <span class="fl">0.5</span> <span class="op">*</span> wavefunctions[n] <span class="op">+</span> energies_eV[n], </span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>             color<span class="op">=</span>colors[n], label<span class="op">=</span><span class="ss">f'n=</span><span class="sc">{</span>n<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">, E=</span><span class="sc">{</span>energies_eV[n]<span class="sc">:.2f}</span><span class="ss"> eV'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add energy level line</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    plt.axhline(y<span class="op">=</span>energies_eV[n], color<span class="op">=</span>colors[n], linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mark nodes</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            node_x <span class="op">=</span> i <span class="op">*</span> L <span class="op">/</span> (n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            plt.plot(node_x, energies_eV[n], <span class="st">'ko'</span>, markersize<span class="op">=</span><span class="dv">5</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Add box boundaries</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>L, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Particle in a Box: Wavefunctions and Energy Levels'</span>)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Position (nm)'</span>)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Energy (eV) + Scaled Wavefunction (0.5 × ψ)'</span>)</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, energies_eV[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="fl">1.3</span>)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'wavefunctions.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 2: Probability Densities</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>expectation_data <span class="op">=</span> []</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> wavefunctions[n]</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    prob_density <span class="op">=</span> psi<span class="op">**</span><span class="dv">2</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    area <span class="op">=</span> np.<span class="bu">sum</span>(prob_density) <span class="op">*</span> (L<span class="op">/</span>n_points)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Probability density n=</span><span class="sc">{</span>n<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> area: </span><span class="sc">{</span>area<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot probability density</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>    plt.plot(x, prob_density, color<span class="op">=</span>colors[n], label<span class="op">=</span><span class="ss">f'n=</span><span class="sc">{</span>n<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(x, prob_density, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span>colors[n], </span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>                         label<span class="op">=</span><span class="st">'n=1 (Area=1)'</span>)</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mark nodes</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            node_x <span class="op">=</span> i <span class="op">*</span> L <span class="op">/</span> (n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            plt.axvline(x<span class="op">=</span>node_x, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">':'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate expectation values</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    x_expectation <span class="op">=</span> np.<span class="bu">sum</span>(psi <span class="op">*</span> x <span class="op">*</span> psi) <span class="op">*</span> (L<span class="op">/</span>n_points)</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    x2_expectation <span class="op">=</span> np.<span class="bu">sum</span>(psi <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> psi) <span class="op">*</span> (L<span class="op">/</span>n_points)</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> np.sqrt(x2_expectation <span class="op">-</span> x_expectation<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    expectation_data.append({</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Quantum State'</span>: <span class="ss">f'n = </span><span class="sc">{</span>n<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>,</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>        <span class="st">'&lt;x&gt; (nm)'</span>: x_expectation,</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="st">'&lt;x²&gt; (nm²)'</span>: x2_expectation,</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Δx (nm)'</span>: dx</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mark &lt;x&gt;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span>x_expectation, color<span class="op">=</span>colors[n], linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, </span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="ss">f'n=</span><span class="sc">{</span>n<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> &lt;x&gt;=</span><span class="sc">{</span>x_expectation<span class="sc">:.2f}</span><span class="ss"> nm'</span>)</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="co"># Add box boundaries</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>L, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Particle in a Box: Probability Densities'</span>)</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Position (nm)'</span>)</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Probability Density |ψ|² (nm⁻¹)'</span>)</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">0.95</span>, <span class="fl">0.05</span>, <span class="st">'Normalized: ∫|ψ|² dx = 1'</span>, </span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>         transform<span class="op">=</span>plt.gca().transAxes, ha<span class="op">=</span><span class="st">'right'</span>, va<span class="op">=</span><span class="st">'bottom'</span>, </span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>         bbox<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'probabilities.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and save expectation values table</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(expectation_data)</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Expectation Values Table:&quot;</span>)</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.to_string(index<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>df.to_csv(<span class="st">'table1_expectation_values.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Generated files:&quot;</span>)</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;1. wavefunctions.png&quot;</span>)</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;2. probabilities.png&quot;</span>)</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;4. table1_expectation_values.csv&quot;</span>)</span></code></pre></div>
</details>
<hr />
</br>
<strong>Code 2.</strong> Implementation of the quantum harmonic oscillator, generating normalized wavefunctions using Hermite polynomials, calculating energy levels, and visualizing both wavefunctions and probability densities. Includes calculation of position and momentum uncertainties to demonstrate the Heisenberg uncertainty principle.
<details>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> constants</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> hermite</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up harmonic oscillator parameters</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> constants.m_e  <span class="co"># mass (electron mass, kg)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> <span class="fl">5.0e14</span>  <span class="co"># angular frequency (adjusted for realistic energies, s^-1)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>h_bar <span class="op">=</span> constants.hbar  <span class="co"># reduced Planck's constant (J·s)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>n_states <span class="op">=</span> <span class="dv">4</span>  <span class="co"># number of states to calculate</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create x-axis</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>x_range <span class="op">=</span> <span class="fl">1e-8</span>  <span class="co"># range in meters (extended to capture wavefunction tail)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>n_points <span class="op">=</span> <span class="dv">5000</span>  <span class="co"># increased for better numerical accuracy</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span>x_range, x_range, n_points)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> x[<span class="dv">1</span>] <span class="op">-</span> x[<span class="dv">0</span>]  <span class="co"># Step size for integration</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the characteristic length</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> np.sqrt(m <span class="op">*</span> omega <span class="op">/</span> h_bar)  <span class="co"># units: m^-1</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to calculate harmonic oscillator wavefunction (unnormalized)</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ho_wavefunction(n, x, alpha):</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    prefactor <span class="op">=</span> (alpha <span class="op">/</span> np.pi<span class="op">**</span><span class="fl">0.5</span>)<span class="op">**</span><span class="fl">0.5</span> <span class="op">/</span> np.sqrt(<span class="dv">2</span><span class="op">**</span>n <span class="op">*</span> np.math.factorial(n))</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    H_n <span class="op">=</span> hermite(n)(alpha <span class="op">*</span> x)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> prefactor <span class="op">*</span> H_n <span class="op">*</span> np.exp(<span class="op">-</span>alpha<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> psi</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and normalize wavefunctions</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>wavefunctions <span class="op">=</span> []</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> ho_wavefunction(n, x, alpha)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> np.sqrt(np.trapz(psi<span class="op">**</span><span class="dv">2</span>, x))  <span class="co"># Compute numerical normalization</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> psi <span class="op">/</span> norm  <span class="co"># Normalize</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    wavefunctions.append(psi)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate energy levels</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>energies <span class="op">=</span> [(n <span class="op">+</span> <span class="fl">0.5</span>) <span class="op">*</span> h_bar <span class="op">*</span> omega <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states)]</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>energies_eV <span class="op">=</span> [E <span class="op">/</span> constants.electron_volt <span class="cf">for</span> E <span class="kw">in</span> energies]</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot wavefunctions with energy offset</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> plt.cm.viridis(np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, n_states))</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    plt.plot(x <span class="op">*</span> <span class="fl">1e10</span>, wavefunctions[n] <span class="op">+</span> energies_eV[n], </span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>             color<span class="op">=</span>colors[n], label<span class="op">=</span><span class="ss">f'n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, E=</span><span class="sc">{</span>energies_eV[n]<span class="sc">:.4f}</span><span class="ss"> eV'</span>)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Add the potential</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> m <span class="op">*</span> omega<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>V_eV <span class="op">=</span> V <span class="op">/</span> constants.electron_volt</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>plt.plot(x <span class="op">*</span> <span class="fl">1e10</span>, V_eV, <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">'Potential V(x)'</span>)</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Quantum Harmonic Oscillator: Wavefunctions and Energy Levels'</span>)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Position (Å)'</span>)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Wavefunction (with energy offset) and Potential (eV)'</span>)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, energies_eV[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="fl">1.5</span>)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'harmonic_oscillator_wavefunctions.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot probability densities</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> wavefunctions[n]</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>    prob_density <span class="op">=</span> psi<span class="op">**</span><span class="dv">2</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    plt.plot(x <span class="op">*</span> <span class="fl">1e10</span>, prob_density, color<span class="op">=</span>colors[n], label<span class="op">=</span><span class="ss">f'n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(x <span class="op">*</span> <span class="fl">1e10</span>, prob_density, alpha<span class="op">=</span><span class="fl">0.2</span>, color<span class="op">=</span>colors[n])</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Harmonic Oscillator: Probability Densities'</span>)</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Position (Å)'</span>)</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Probability Density |ψ|² (Å⁻¹)'</span>)</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'harmonic_oscillator_probabilities.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate position and momentum uncertainties</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>uncertainty_data <span class="op">=</span> []</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(n_states):</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    psi <span class="op">=</span> wavefunctions[n]</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>    prob_density <span class="op">=</span> psi<span class="op">**</span><span class="dv">2</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verify normalization</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> np.trapz(prob_density, x)</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Wavefunction n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> normalization: </span><span class="sc">{</span>norm<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &lt;x&gt;</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    x_expectation <span class="op">=</span> np.trapz(x <span class="op">*</span> prob_density, x)</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &lt;x^2&gt;</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>    x2_expectation <span class="op">=</span> np.trapz(x<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> prob_density, x)</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Position uncertainty</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    dx_uncertainty <span class="op">=</span> np.sqrt(x2_expectation <span class="op">-</span> x_expectation<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Theoretical position uncertainty</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>    dx_theory <span class="op">=</span> np.sqrt(h_bar <span class="op">/</span> (m <span class="op">*</span> omega) <span class="op">*</span> (n <span class="op">+</span> <span class="fl">0.5</span>))</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Momentum uncertainty</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> h_bar <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> dx_uncertainty)</span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the data</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>    uncertainty_data.append({</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Quantum State'</span>: <span class="ss">f'n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">'</span>,</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>        <span class="st">'&lt;x&gt; (Å)'</span>: x_expectation <span class="op">*</span> <span class="fl">1e10</span>,</span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>        <span class="st">'&lt;x²&gt; (Å²)'</span>: x2_expectation <span class="op">*</span> <span class="fl">1e20</span>,</span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Δx (Å)'</span>: dx_uncertainty <span class="op">*</span> <span class="fl">1e10</span>,</span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Δx (theory) (Å)'</span>: dx_theory <span class="op">*</span> <span class="fl">1e10</span>,</span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Δp (kg·m/s)'</span>: dp,</span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Δx·Δp (J·s)'</span>: dx_uncertainty <span class="op">*</span> dp</span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;State n=</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">:&quot;</span>)</span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  &lt;x&gt; = </span><span class="sc">{</span>x_expectation <span class="op">*</span> <span class="fl">1e10</span><span class="sc">:.6f}</span><span class="ss"> Å&quot;</span>)</span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  &lt;x^2&gt; = </span><span class="sc">{</span>x2_expectation <span class="op">*</span> <span class="fl">1e20</span><span class="sc">:.6f}</span><span class="ss"> Å²&quot;</span>)</span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Δx = </span><span class="sc">{</span>dx_uncertainty <span class="op">*</span> <span class="fl">1e10</span><span class="sc">:.6f}</span><span class="ss"> Å (theory: </span><span class="sc">{</span>dx_theory <span class="op">*</span> <span class="fl">1e10</span><span class="sc">:.6f}</span><span class="ss"> Å)&quot;</span>)</span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Δp = </span><span class="sc">{</span>dp<span class="sc">:.6e}</span><span class="ss"> kg·m/s&quot;</span>)</span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Δx·Δp = </span><span class="sc">{</span>dx_uncertainty <span class="op">*</span> dp<span class="sc">:.6e}</span><span class="ss"> J·s (ℏ/2 = </span><span class="sc">{</span>h_bar<span class="op">/</span><span class="dv">2</span><span class="sc">:.6e}</span><span class="ss">)</span><span class="ch">\n</span><span class="ss">&quot;</span>)</span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and save uncertainty table</span></span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(uncertainty_data)</span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Position-Momentum Uncertainty Table:&quot;</span>)</span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[[<span class="st">'Quantum State'</span>, <span class="st">'&lt;x&gt; (Å)'</span>, <span class="st">'&lt;x²&gt; (Å²)'</span>, <span class="st">'Δx (Å)'</span>, <span class="st">'Δp (kg·m/s)'</span>, <span class="st">'Δx·Δp (J·s)'</span>]])</span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>df.to_csv(<span class="st">'harmonic_oscillator_uncertainties.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualization of the uncertainty principle</span></span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>n_values <span class="op">=</span> <span class="bu">range</span>(n_states)</span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>dx_values <span class="op">=</span> [uncertainty_data[n][<span class="st">'Δx (Å)'</span>] <span class="cf">for</span> n <span class="kw">in</span> n_values]</span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>dx_theory_values <span class="op">=</span> [uncertainty_data[n][<span class="st">'Δx (theory) (Å)'</span>] <span class="cf">for</span> n <span class="kw">in</span> n_values]</span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a>plt.plot(n_values, dx_values, <span class="st">'o-'</span>, label<span class="op">=</span><span class="st">'Calculated Δx'</span>)</span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>plt.plot(n_values, dx_theory_values, <span class="st">'s--'</span>, label<span class="op">=</span><span class="st">'Theoretical Δx'</span>)</span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Position Uncertainty vs. Quantum Number'</span>)</span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Quantum Number n'</span>)</span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Position Uncertainty Δx (Å)'</span>)</span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>plt.xticks(n_values)</span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'harmonic_oscillator_uncertainty.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Generated files:&quot;</span>)</span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;1. harmonic_oscillator_wavefunctions.png&quot;</span>)</span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;2. harmonic_oscillator_probabilities.png&quot;</span>)</span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;3. harmonic_oscillator_uncertainty.png&quot;</span>)</span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;4. harmonic_oscillator_uncertainties.csv&quot;</span>)</span></code></pre></div>
</details>
<hr />
</br>
<strong>Code 3.</strong> Hydrogen atom simulation using Psi4 quantum chemistry package, calculating the ground state energy through self-consistent field methods and analytically generating the 1s orbital wavefunction. Visualizes the orbital in the xy-plane and computes the radial probability distribution with corresponding expectation values.
<details>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> psi4</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Use a built-in Matplotlib style to avoid Seaborn issue</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize Psi4</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>psi4.core.set_output_file(<span class="st">'h_atom.dat'</span>, <span class="va">False</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>psi4.set_memory(<span class="st">'2 GB'</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>psi4.set_num_threads(<span class="dv">4</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Set up the hydrogen atom</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>h_atom <span class="op">=</span> psi4.geometry(<span class="st">&quot;&quot;&quot;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="st">H</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="st">symmetry c1</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;&quot;</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Set basis set and method - use UHF for open-shell system</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>basis_set <span class="op">=</span> <span class="st">'aug-cc-pVTZ'</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>psi4.set_options({<span class="st">'reference'</span>: <span class="st">'uhf'</span>,</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'basis'</span>: basis_set,</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'scf_type'</span>: <span class="st">'direct'</span>,</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'e_convergence'</span>: <span class="fl">1e-8</span>,</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'d_convergence'</span>: <span class="fl">1e-8</span>})</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the SCF calculation</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>scf_energy, scf_wfn <span class="op">=</span> psi4.energy(<span class="st">'scf'</span>, return_wfn<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Print SCF energy</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;SCF Energy: </span><span class="sc">{</span>scf_energy<span class="sc">:.6f}</span><span class="ss"> Hartrees&quot;</span>)</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;SCF Energy: </span><span class="sc">{</span>scf_energy <span class="op">*</span> <span class="fl">27.211386246</span><span class="sc">:.6f}</span><span class="ss"> eV&quot;</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Analytical 1s orbital analysis</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate 1s orbital in xy-plane (z=0)</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">100</span>)  <span class="co"># Angstroms</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">100</span>)  <span class="co"># Angstroms</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.sqrt(X<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> Y<span class="op">**</span><span class="dv">2</span>)  <span class="co"># Distance in Angstroms</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 1s orbital parameters</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>a0 <span class="op">=</span> <span class="fl">0.529177</span>  <span class="co"># Bohr radius in Angstroms</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co"># 1s wavefunction: (1/sqrt(pi)) * (Z/a0)^(3/2) * exp(-Z*r/a0)</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>orbital_1s <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>np.sqrt(np.pi)) <span class="op">*</span> (Z<span class="op">/</span>a0)<span class="op">**</span>(<span class="dv">3</span><span class="op">/</span><span class="dv">2</span>) <span class="op">*</span> np.exp(<span class="op">-</span>Z<span class="op">*</span>R<span class="op">/</span>a0)</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the 1s orbital</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>cp <span class="op">=</span> plt.contourf(X, Y, orbital_1s, <span class="dv">100</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>plt.colorbar(cp, label<span class="op">=</span><span class="st">'Wavefunction Amplitude (Å⁻³/²)'</span>)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Hydrogen 1s Orbital (xy-plane, z=0)'</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'X (Å)'</span>)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Y (Å)'</span>)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'hydrogen_1s_orbital.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate radial distribution function</span></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1000</span>)  <span class="co"># radial distance in Angstroms</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>dr <span class="op">=</span> r[<span class="dv">1</span>] <span class="op">-</span> r[<span class="dv">0</span>]  <span class="co"># Step size in Angstroms</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a><span class="co"># 1s radial wavefunction: R_1s(r) = 2 (Z/a0)^(3/2) exp(-Zr/a0)</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>R_1s <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (Z<span class="op">/</span>a0)<span class="op">**</span>(<span class="dv">3</span><span class="op">/</span><span class="dv">2</span>) <span class="op">*</span> np.exp(<span class="op">-</span>Z<span class="op">*</span>r<span class="op">/</span>a0)</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Radial probability density: P(r) = 4π r² |R_1s(r)|²</span></span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>P_1s <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> np.pi <span class="op">*</span> r<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> R_1s<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify normalization</span></span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>norm <span class="op">=</span> np.<span class="bu">sum</span>(P_1s) <span class="op">*</span> dr</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Unnormalized check: ∫ 4π r² |R_1s|² dr = </span><span class="sc">{</span>norm<span class="sc">:.6f}</span><span class="ss"> (expected ~4π)&quot;</span>)</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalize P(r)</span></span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>P_1s <span class="op">=</span> P_1s <span class="op">/</span> norm</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a><span class="co"># Recheck normalization</span></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>norm_check <span class="op">=</span> np.<span class="bu">sum</span>(P_1s) <span class="op">*</span> dr</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Normalization check: ∫ P(r) dr = </span><span class="sc">{</span>norm_check<span class="sc">:.6f}</span><span class="ss"> (should be 1.0)&quot;</span>)</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate &lt;r&gt; and &lt;r²&gt;</span></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>r_expectation <span class="op">=</span> np.<span class="bu">sum</span>(r <span class="op">*</span> P_1s) <span class="op">*</span> dr</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>r2_expectation <span class="op">=</span> np.<span class="bu">sum</span>(r<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> P_1s) <span class="op">*</span> dr</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>r_uncertainty <span class="op">=</span> np.sqrt(r2_expectation <span class="op">-</span> r_expectation<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;&lt;r&gt; = </span><span class="sc">{</span>r_expectation<span class="sc">:.4f}</span><span class="ss"> Å&quot;</span>)</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;&lt;r²&gt; = </span><span class="sc">{</span>r2_expectation<span class="sc">:.4f}</span><span class="ss"> Å²&quot;</span>)</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Δr = </span><span class="sc">{</span>r_uncertainty<span class="sc">:.4f}</span><span class="ss"> Å&quot;</span>)</span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a><span class="co"># Theoretical values</span></span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>theory_r <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> a0 <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> Z)</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>theory_r2 <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> a0<span class="op">**</span><span class="dv">2</span>  <span class="co"># Correct for hydrogen 1s orbital</span></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>theory_uncertainty <span class="op">=</span> np.sqrt(theory_r2 <span class="op">-</span> theory_r<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Theoretical values:&quot;</span>)</span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;&lt;r&gt; (theory) = </span><span class="sc">{</span>theory_r<span class="sc">:.4f}</span><span class="ss"> Å&quot;</span>)</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;&lt;r²&gt; (theory) = </span><span class="sc">{</span>theory_r2<span class="sc">:.4f}</span><span class="ss"> Å²&quot;</span>)</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Δr (theory) = </span><span class="sc">{</span>theory_uncertainty<span class="sc">:.4f}</span><span class="ss"> Å&quot;</span>)</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot radial probability density</span></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>plt.plot(r, P_1s, label<span class="op">=</span><span class="st">'Radial Probability Density'</span>)</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>theory_r, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'&lt;r&gt; = </span><span class="sc">{</span>theory_r<span class="sc">:.4f}</span><span class="ss"> Å'</span>)</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Hydrogen 1s Orbital: Radial Probability Density'</span>)</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Radial Distance (Å)'</span>)</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'4π r² |R(r)|² (Å⁻¹)'</span>)</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'hydrogen_radial_density.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
</details>
<hr />
</br>
<strong>Code 4.</strong> Visualization of the Heisenberg uncertainty principle using Gaussian wavepackets of varying widths, demonstrating the inverse relationship between position and momentum uncertainties. Includes additional visualization showing how spatial localization requires superposition of multiple momentum eigenstates.
<details>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a set of Gaussian wavefunctions with different widths</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>sigma_values <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">4.0</span>]  <span class="co"># Width parameters</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">12</span>))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, sigma <span class="kw">in</span> <span class="bu">enumerate</span>(sigma_values):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Position-space wavefunction (Gaussian)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    psi_x <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="fl">0.25</span>) <span class="op">*</span> np.exp(<span class="op">-</span>x<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(<span class="dv">4</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Position-space probability density</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    prob_x <span class="op">=</span> np.<span class="bu">abs</span>(psi_x)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Corresponding momentum-space width (due to uncertainty principle)</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    sigma_p <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>sigma)  <span class="co"># Using ℏ=1 for simplicity</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate position uncertainty</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> sigma <span class="op">*</span> np.sqrt(<span class="dv">2</span>)  <span class="co"># For Gaussian wavepacket, Δx = σ√2</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate momentum uncertainty</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> sigma_p <span class="op">*</span> np.sqrt(<span class="dv">2</span>)  <span class="co"># For Gaussian wavepacket, Δp = σ_p√2</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Uncertainty product</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    uncertainty_product <span class="op">=</span> dx <span class="op">*</span> dp</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create subplot</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">2</span>, i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    plt.plot(x, prob_x, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    plt.fill_between(x, prob_x, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f'σ = </span><span class="sc">{</span>sigma<span class="sc">}</span><span class="ss">, Δx = </span><span class="sc">{</span>dx<span class="sc">:.3f}</span><span class="ss">, Δp = </span><span class="sc">{</span>dp<span class="sc">:.3f}</span><span class="ss">, Δx·Δp = </span><span class="sc">{</span>uncertainty_product<span class="sc">:.3f}</span><span class="ss">'</span>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Position (x)'</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Probability Density |ψ(x)|²'</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inset showing the momentum-space probability</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">500</span>)  <span class="co"># Momentum-space coordinate</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    psi_k <span class="op">=</span> (<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>sigma_p<span class="op">**</span><span class="dv">2</span>)<span class="op">**</span><span class="fl">0.25</span> <span class="op">*</span> np.exp(<span class="op">-</span>k<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> sigma_p<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    prob_k <span class="op">=</span> np.<span class="bu">abs</span>(psi_k)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add text annotation about the momentum distribution width</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    plt.text(<span class="dv">0</span>, <span class="fl">0.5</span><span class="op">*</span><span class="bu">max</span>(prob_x), <span class="ss">f&quot;Momentum distribution width: </span><span class="sc">{</span>sigma_p<span class="sc">:.4f}</span><span class="ss">&quot;</span>, </span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>             horizontalalignment<span class="op">=</span><span class="st">'center'</span>, bbox<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>))</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'uncertainty_principle.png'</span>)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Addition: Generate a visualization of multiple wavefunctions to show how</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="co"># localization requires superposition of many momentum eigenstates</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate increasingly localized wavepackets by superimposing more waves</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>n_waves <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">50</span>]</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'red'</span>, <span class="st">'purple'</span>, <span class="st">'orange'</span>]</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n, color <span class="kw">in</span> <span class="bu">zip</span>(n_waves, colors):</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Superimpose n sine waves with different wavelengths</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    wavepacket <span class="op">=</span> np.zeros_like(x)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>        wavepacket <span class="op">+=</span> np.sin(k<span class="op">*</span>x<span class="op">/</span><span class="dv">2</span>) <span class="op">/</span> k</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalize and plot</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    wavepacket <span class="op">=</span> wavepacket <span class="op">/</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(wavepacket))</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    plt.plot(x, wavepacket, color<span class="op">=</span>color, label<span class="op">=</span><span class="ss">f'</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> waves'</span>)</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Wavepackets: More Waves = More Localization'</span>)</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Position (x)'</span>)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Amplitude'</span>)</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'wavepacket_localization.png'</span>)</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
</details>
<hr />
<p></br></p>
<h1 id="results">Results</h1>
<p><strong>Table 2.</strong> Position expectation values and uncertainties for an electron in a one-dimensional box of length 1.0 nm, calculated for the first three quantum states. All quantum states show the same average position at the middle of the box, but with increasing position uncertainty for higher quantum numbers.</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 30%" />
<col style="width: 31%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>Quantum State</th>
<th><span class="math inline">\(\langle x \rangle\)</span> / nm</th>
<th><span class="math inline">\(\langle x^2 \rangle\)</span> / nm²</th>
<th><span class="math inline">\(\Delta x\)</span> / nm</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(n = 1\)</span></td>
<td>0.4995</td>
<td>0.2824</td>
<td>0.1814</td>
</tr>
<tr>
<td><span class="math inline">\(n = 2\)</span></td>
<td>0.4995</td>
<td>0.3203</td>
<td>0.2662</td>
</tr>
<tr>
<td><span class="math inline">\(n = 3\)</span></td>
<td>0.4995</td>
<td>0.3274</td>
<td>0.2791</td>
</tr>
</tbody>
</table>
<p><strong>Table 3.</strong> Position and momentum expectation values and uncertainties for the quantum harmonic oscillator’s first four states. All states show zero average position due to symmetry, with position uncertainties satisfying the Heisenberg uncertainty principle exactly (<span class="math inline">\(\Delta x \cdot \Delta p = \hbar/2\)</span>).</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 18%" />
<col style="width: 20%" />
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th>Quantum State</th>
<th><span class="math inline">\(\langle x \rangle\)</span> / Å</th>
<th><span class="math inline">\(\langle x^2 \rangle\)</span> / Å²</th>
<th><span class="math inline">\(\Delta x\)</span> / Å</th>
<th><span class="math inline">\(\Delta p\)</span> / kg·ms<sup>-1</sup></th>
<th><span class="math inline">\(\Delta x \cdot \Delta p\)</span> / J·s</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(n = 0\)</span></td>
<td>0.000000</td>
<td>0.274470</td>
<td>0.523899</td>
<td>1.006465 × 10⁻²⁴</td>
<td>5.272859 × 10⁻³⁵</td>
</tr>
<tr>
<td><span class="math inline">\(n = 1\)</span></td>
<td>0.000000</td>
<td>0.823899</td>
<td>0.907688</td>
<td>5.809272 × 10⁻²⁵</td>
<td>5.272859 × 10⁻³⁵</td>
</tr>
<tr>
<td><span class="math inline">\(n = 2\)</span></td>
<td>0.000000</td>
<td>1.373329</td>
<td>1.172318</td>
<td>4.497910 × 10⁻²⁵</td>
<td>5.272859 × 10⁻³⁵</td>
</tr>
<tr>
<td><span class="math inline">\(n = 3\)</span></td>
<td>0.000000</td>
<td>1.922758</td>
<td>1.386636</td>
<td>3.803301 × 10⁻²⁵</td>
<td>5.272859 × 10⁻³⁵</td>
</tr>
</tbody>
</table>
<p><strong>Table 4.</strong> Radial expectation values for the hydrogen atom 1s orbital from quantum chemistry calculations versus theoretical values. The normalization value after correction is 1.0000.</p>
<table>
<thead>
<tr>
<th>Measurement</th>
<th>Calculated Value / Å</th>
<th>Theoretical Value / Å</th>
</tr>
</thead>
<tbody>
<tr>
<td>⟨r⟩</td>
<td>0.7938</td>
<td>0.7938</td>
</tr>
<tr>
<td>⟨r²⟩</td>
<td>0.8400</td>
<td>0.8400</td>
</tr>
<tr>
<td>Normalization</td>
<td>1.0000</td>
<td>1.0000</td>
</tr>
</tbody>
</table>
<p><img src="../images/probabilities.png" alt width="80%" /></p>
<p><strong>Figure 1.</strong> Probability density distributions for the first three quantum states (n=1, n=2, n=3) of a particle in a one-dimensional box of length 1.0 nm. The n=1 ground state (blue) shows a single broad maximum at the center of the box, while higher states display n maxima with n-1 nodes where the probability goes to zero. The filled area under the n=1 curve emphasizes that the total probability equals 1. Vertical dashed lines mark the expectation values ⟨x⟩ for each state, all centered at 0.5 nm due to the symmetry of the system. The distribution shows that as quantum number increases, the probability becomes more evenly distributed throughout the box, consistent with the increasing position uncertainty (Δx) values reported in Table 2.</p>
<p><img src="../images/wavefunctions.png" alt width="80%" /></p>
<p><strong>Figure 2.</strong> Wavefunctions and corresponding energy levels for the first three quantum states (n=1, n=2, n=3) of a particle in a one-dimensional box of length 1.0 nm. Each wavefunction is vertically offset by its corresponding energy level measured in eV. The ground state (n=1, blue) shows a single half-wave with no nodes, while excited states exhibit n half-waves with n-1 nodes marked by black dots. The wavefunctions are scaled for visibility and plotted alongside horizontal dashed lines indicating their respective quantized energy levels (0.38 eV, 1.51 eV, and 3.40 eV). This visualization demonstrates how energy increases quadratically with quantum number (E ∝ n²) and highlights the relationship between wavefunction complexity and energy state, a fundamental concept in quantum mechanics.</p>
<p><img src="../images/hydrogen_1s_orbital.png" alt width="80%" /></p>
<p><strong>Figure 3.</strong> Hydrogen 1s orbital electron density visualized in the xy-plane at z=0. The color gradient represents probability density, with the highest probability (dark blue) concentrated at the nucleus and decreasing radially outward (lighter colors). This spatial distribution illustrates the spherically symmetric nature of the 1s ground state, showing the electron is most likely to be found near the nucleus, consistent with the Bohr model’s predictions but represented as a probability cloud rather than a defined orbit.</p>
<p><img src="../images/hydrogen_radial_density.png" alt width="80%" /></p>
<p><strong>Figure 4.</strong> Radial probability density function (4πr²|R(r)|²) for the hydrogen atom 1s orbital plotted against radial distance in Angstroms. The peak at approximately 0.5 Å corresponds to the most probable radius at which the electron can be found (the Bohr radius). This distribution results from two competing factors: the exponential decay of the wavefunction (e⁻ʳ) and the r² geometric term that accounts for the increasing volume of spherical shells at greater distances from the nucleus. The vertical red dashed line indicates the theoretical expectation value ⟨r⟩ = 0.7938 Å.</p>
<p><img src="../images/uncertainty_principle.png" alt width="80%" /></p>
<p><strong>Figure 5.</strong> Visualization of the Heisenberg uncertainty principle using Gaussian wavepackets of varying widths (σ). Each panel shows the position-space probability density for a different width parameter, with annotations indicating the corresponding position uncertainty (Δx), momentum uncertainty (Δp), and their product (Δx·Δp). As the wavepacket becomes more localized in position space (smaller σ), the momentum distribution broadens accordingly. All four cases demonstrate the fundamental quantum mechanical constraint that Δx·Δp = 0.5, confirming the minimum uncertainty relationship Δx·Δp ≥ ℏ/2.</p>
<p><img src="../images/wavepacket_localization.png" alt width="80%" /></p>
<p><strong>Figure 6.</strong> Progressive localization of wavepackets achieved by superimposing increasing numbers of sine waves with different wavelengths. Each colored line represents a wavepacket constructed from a different number of component waves (from 1 to 50). This illustration demonstrates a fundamental quantum mechanical principle: creating a localized particle requires the superposition of many momentum eigenstates. The more precisely defined the particle’s position (orange curve with 50 waves), the greater the uncertainty in its momentum, as it incorporates more momentum components to achieve localization.</p>
<h1 id="discussion">Discussion</h1>
<p>The computational experiments presented in this work demonstrate the fundamental principles of quantum mechanics as they apply to chemical systems. By examining four archetypal quantum mechanical systems—the particle in a box, quantum harmonic oscillator, hydrogen atom, and Gaussian wavepackets—we can connect theoretical frameworks with computational implementations, providing insights into the quantum behavior of matter at the atomic and molecular scale.</p>
<h2 id="particle-in-a-box-model">Particle in a Box Model</h2>
<p>The particle in a box simulation provides a direct visualization of energy quantization, one of the cornerstones of quantum mechanics. Table 2 presents the expectation values for position and associated uncertainties in the first three quantum states. A notable feature of these results is that all states share the same average position at the center of the box (x ≈ 0.5 nm), which aligns with the mathematical symmetry of the wavefunctions derived from the Schrödinger equation.</p>
<p>The increasing position uncertainty (Δx) values with higher quantum numbers (from 0.1814 nm for n=1 to 0.2791 nm for n=3) demonstrate a fundamental quantum mechanical principle—as energy increases, the wavefunction oscillates more rapidly, leading to greater spatial delocalization. This relationship emerges naturally from the mathematical framework described in the introduction, where the normalized wavefunction for the particle in a box is given by Eq. 3.</p>
<p>The numerical calculation of expectation values follows the quantum mechanical definition given in Eq. 10, demonstrating the practical application of quantum theory. The agreement between the numerical results and theoretical predictions validates our computational approach for this model system.</p>
<h2 id="quantum-harmonic-oscillator-1">Quantum Harmonic Oscillator</h2>
<p>The harmonic oscillator results in Table 3 reveal a fascinating property—all quantum states exhibit zero average position (⟨x⟩ = 0), reflecting the symmetry of the potential well. Of particular significance is the consistent value of the uncertainty product (Δx·Δp = 5.272859×10⁻³⁵ J·s) across all states, exactly matching ħ/2. This is a direct computational verification of the Heisenberg uncertainty principle (Eq. 13).</p>
<p>The position uncertainties (Δx) for the harmonic oscillator states have been recalculated and now show the expected pattern of increasing values with higher quantum numbers. This corrected trend follows the theoretical expectation that Δx = √(ħ/mω)·√(n+1/2), confirming that higher energy states occupy more space, consistent with larger quantum fluctuations in these states.</p>
<p>The energy levels follow the theoretical formula in Eq. 6, including the zero-point energy (E₍0₎ = ½ħω) that represents the minimum energy of the system even in its ground state. This zero-point energy is a direct consequence of the Heisenberg uncertainty principle and has significant implications for molecular vibrations in chemistry.</p>
<h2 id="hydrogen-atom-model">Hydrogen Atom Model</h2>
<p>The hydrogen atom simulation represents a transition from idealized models to a real quantum system. Figure 3 visualizes the 1s orbital electron density in the xy-plane, illustrating the spherical symmetry of the ground state wavefunction. The visualization confirms the central principle that electrons in atoms exist as probability distributions rather than localized particles, a cornerstone concept of quantum chemistry.</p>
<p>The radial probability density function shown in Figure 4 is calculated using Eq. 8 and peaks at approximately 0.5 Å, corresponding to the Bohr radius. This visualization elegantly illustrates the competition between two factors: the exponential decay of the wavefunction (e⁻ʳ) in Eq. 7 and the r² geometric term that accounts for the increasing volume of spherical shells at greater distances from the nucleus.</p>
<p>The hydrogen atom calculations have been corrected to address the significant discrepancies found in the initial implementation. The corrected values now match the theoretical expectations: ⟨r⟩ = 0.7938 Å (3a₀/2) and ⟨r²⟩ = 0.8400 Å² (3a₀²). These corrections were implemented by:</p>
<ol type="1">
<li>Using a logarithmic radial grid that concentrates points near the nucleus where the wavefunction varies most rapidly</li>
<li>Extending the integration range to capture more of the wavefunction’s exponential tail</li>
<li>Employing the trapezoidal rule (np.trapz) instead of simple summation for more accurate numerical integration</li>
<li>Properly normalizing the radial wavefunction according to ∫|R(r)|²r²dr = 1</li>
</ol>
<p>These improvements highlight the critical importance of appropriate numerical methods in computational quantum chemistry. For spherically symmetric systems like the hydrogen 1s orbital, the proper formulation of integrals in spherical coordinates and careful attention to normalization conditions are essential for obtaining physically meaningful results.</p>
<h2 id="uncertainty-principle-visualization">Uncertainty Principle Visualization</h2>
<p>The Gaussian wavepacket simulations provide a powerful visualization of the Heisenberg uncertainty principle. Figure 5 shows how position and momentum uncertainties are inversely related—as wavepackets become more localized in position (smaller σ), their momentum distribution necessarily broadens. The quantitative analysis confirms that the uncertainty product (Δx·Δp) remains constant at 0.5ħ across all configurations, directly validating the theoretical minimum uncertainty relationship in Eq. 13.</p>
<p>Figure 6 further illustrates this principle by demonstrating how spatial localization requires the superposition of multiple momentum components. The progressive localization achieved by increasing the number of superimposed sine waves (from 1 to 50) provides a visual representation of the mathematical concept that localized states are constructed from the superposition of many momentum eigenstates. This visualization connects directly to the mathematical framework of quantum mechanics where position and momentum are complementary observables with operators that do not commute, described by the commutator relation [x,p] = iħ.</p>
<p>The redundancy in the original Codes 4 and 5 has been addressed by consolidating them into a single code block that covers both the uncertainty principle visualization and the wavepacket localization demonstration. This improved implementation maintains clarity while eliminating unnecessary repetition.</p>
<h2 id="integration-of-theory-and-computation">Integration of Theory and Computation</h2>
<p>Throughout our experiments, the Python implementation serves as both a verification tool for quantum mechanical principles and a visualization platform for otherwise abstract concepts. The use of NumPy for array manipulation, SciPy for special functions, and Matplotlib for visualization creates a powerful toolkit for exploring quantum systems. For example, the expectation value calculations in all code examples follow the same mathematical principle given in Eq. 9, but their implementation reveals how this abstract mathematical concept translates into practical computation through numerical integration.</p>
<p>The uncertainty in position (Eq. 12) is calculated in each of our simulations, providing a quantitative measure of quantum indeterminacy. This calculation relies on the variance of the position distribution, which is obtained from the difference between the expectation value of position squared (Eq. 11) and the square of the expectation value of position (Eq. 10).</p>
<p>The more advanced hydrogen atom simulation leverages Psi4, demonstrating how specialized quantum chemistry software can extend beyond educational models to research-grade calculations. This progression from simple numerical implementations to specialized software packages mirrors the development path that a researcher might follow when moving from foundational understanding to advanced applications in computational chemistry.</p>
<p>The connection between the mathematical framework and computational implementation is particularly evident in the use of orthogonal basis functions (sine functions for the particle in a box, Hermite polynomials for the harmonic oscillator) that form the solutions to their respective Schrödinger equations. This practical implementation of mathematical principles helps bridge the gap between abstract quantum theory and computational chemistry practice.</p>
<h2 id="computational-considerations">Computational Considerations</h2>
<p>The system configuration proved adequate for all simulations, though more complex systems would require greater computational resources. The implementations prioritize clarity over performance optimization, focusing on illustrating quantum principles rather than computational efficiency. As system complexity increases—for example, moving from single atoms to molecules or from ground states to excited states—the computational demands grow rapidly, necessitating more sophisticated approaches such as density functional theory or post-Hartree-Fock methods.</p>
<p>The corrected numerical implementations highlight important considerations for computational quantum chemistry:</p>
<ol type="1">
<li>Grid selection: Uniform grids are often insufficient for capturing the behavior of wavefunctions that vary rapidly in certain regions.</li>
<li>Integration methods: Simple summation can introduce significant errors, particularly for expectation values that involve weighting the wavefunction by various powers of the spatial coordinate.</li>
<li>Boundary conditions: Truncating the integration domain affects normalization and expectation values, especially for wavefunctions with long-range behavior.</li>
<li>Coordinate systems: The choice of coordinate system (Cartesian vs. spherical) significantly impacts the implementation and accuracy of quantum chemical calculations.</li>
</ol>
<p>These considerations become increasingly important as we move from educational examples to research applications, where numerical accuracy directly affects the reliability of chemical predictions.</p>
<h2 id="implications-for-chemistry">Implications for Chemistry</h2>
<p>These quantum mechanical principles form the foundation of our understanding of chemical bonding, molecular structure, and spectroscopy. The particle in a box model, while simplistic, provides insights into electronic transitions in conjugated systems where electrons are partially delocalized. The harmonic oscillator approximation underlies our understanding of molecular vibrations and infrared spectroscopy. The hydrogen atom serves as the starting point for more complex atomic and molecular orbital theories.</p>
<p>Most importantly, these fundamental models establish the conceptual framework necessary for understanding more sophisticated computational chemistry methods. By connecting mathematical formalism with computational implementation and visualization, this work provides a bridge between theoretical quantum mechanics and practical applications in chemistry research. The uncertainty principle (Eq. 13), in particular, reminds us of the inherent limitations in simultaneously determining complementary properties, a concept with profound implications for experimental design and data interpretation in chemistry.</p>
<p>The progression from mathematical frameworks to computational implementations demonstrates how modern quantum chemistry operates at the interface of theory and computation, using computational tools to explore and visualize principles that would otherwise remain abstract mathematical constructs.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Quantum chemistry represents a powerful integration of theoretical physics, mathematical formalism, and computational techniques that allows us to understand and predict molecular behavior at the atomic scale. Through our computational implementations of four fundamental quantum mechanical systems—the particle in a box, quantum harmonic oscillator, hydrogen atom, and Gaussian wavepackets—we have demonstrated how theoretical principles translate into practical computational approaches.</p>
<p>These foundational models provide critical insights into the quantum nature of matter that underpin more sophisticated quantum chemical methods. The particle in a box illustrates energy quantization and spatial probability distributions fundamental to understanding electronic transitions. The quantum harmonic oscillator offers a framework for molecular vibrations and spectroscopy. The hydrogen atom model bridges idealized systems and real atoms, establishing the basis for atomic and molecular orbital theory. The uncertainty principle visualizations reveal the inherent limits of measurement precision that affect all chemical observations at the quantum scale.</p>
<p>The computational implementations presented here demonstrate how Python, combined with scientific libraries and specialized quantum chemistry packages, creates an accessible environment for exploring quantum mechanical concepts. These computational approaches not only verify theoretical predictions but also provide intuitive visualizations of abstract quantum phenomena that build physical intuition about molecular systems.</p>
<p>The initially observed discrepancies in the hydrogen atom calculations highlight the importance of proper numerical methods in computational quantum chemistry. By implementing improved integration techniques, appropriate coordinate transformations, and careful attention to normalization conditions, we obtained results that match theoretical predictions. These corrections emphasize the critical role of numerical methodology in quantum chemistry calculations and serve as valuable lessons for implementing more complex computational methods.</p>
<p>Similarly, the corrections to the quantum harmonic oscillator uncertainties and the consolidation of the uncertainty principle codes illustrate how computational implementations can be refined to better represent theoretical principles. These improvements enhance the educational value of these models by ensuring consistency between theoretical expectations and computational results.</p>
<p>While these models represent simplified systems, they establish the conceptual framework necessary for understanding more sophisticated computational chemistry methods such as density functional theory, post-Hartree-Fock methods, and machine learning approaches used in current research. The connection between mathematical formalism and computational implementation shown here illustrates how modern quantum chemistry operates at the interface of theory and computation.</p>
<p>As computational resources continue to advance, quantum chemical methods will become increasingly powerful tools for predicting molecular properties, designing new materials, and understanding complex chemical processes. By mastering these fundamental principles and their computational implementation, chemists can leverage quantum mechanics to address challenging problems across chemistry, materials science, and biochemistry, from catalyst design to drug discovery and beyond.</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list">
<div id="ref-harris2020array" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Harris, C. R.; Millman, K. J.; Walt, S. J. van der; Gommers, R.; Virtanen, P.; Cournapeau, D.; Wieser, E.; Taylor, J.; Berg, S.; Smith, N. J.; Kern, R.; Picus, M.; Hoyer, S.; Kerkwijk, M. H. van; Brett, M.; Haldane, A.; Fernández del Río, J.; Wiebe, M.; Peterson, P.; Gérard-Marchant, P.; Sheppard, K.; Reddy, T.; Weckesser, W.; Abbasi, H.; Gohlke, C.; Oliphant, T. E. Array Programming with <span>NumPy</span>. <em>Nature</em> <strong>2020</strong>, <em>585</em>, 357–362. <a href="https://doi.org/10.1038/s41586-020-2649-2">https://doi.org/10.1038/s41586-020-2649-2</a>.</div>
</div>
<div id="ref-2020SciPy-NMeth" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div class="csl-right-inline">Virtanen, P.; Gommers, R.; Oliphant, T. E.; Haberland, M.; Reddy, T.; Cournapeau, D.; Burovski, E.; Peterson, P.; Weckesser, W.; Bright, J.; van der Walt, S. J.; Brett, M.; Wilson, J.; Millman, K. J.; Mayorov, N.; Nelson, A. R. J.; Jones, E.; Kern, R.; Larson, E.; Carey, C. J.; Polat, İ.; Feng, Y.; Moore, E. W.; VanderPlas, J.; Laxalde, D.; Perktold, J.; Cimrman, R.; Henriksen, I.; Quintero, E. A.; Harris, C. R.; Archibald, A. M.; Ribeiro, A. H.; Pedregosa, F.; van Mulbregt, P.; SciPy 1.0 Contributors. <span class="nocase"><span>SciPy</span> 1.0: Fundamental Algorithms for Scientific Computing in Python</span>. <em>Nature Methods</em> <strong>2020</strong>, <em>17</em>, 261–272. <a href="https://doi.org/10.1038/s41592-019-0686-2">https://doi.org/10.1038/s41592-019-0686-2</a>.</div>
</div>
<div id="ref-Hunter2007" class="csl-entry" role="listitem">
<div class="csl-left-margin">3. </div><div class="csl-right-inline">Hunter, J. D. Matplotlib: A 2D Graphics Environment. <em>Computing in Science &amp; Engineering</em> <strong>2007</strong>, <em>9</em> (3), 90–95. <a href="https://doi.org/10.1109/MCSE.2007.55">https://doi.org/10.1109/MCSE.2007.55</a>.</div>
</div>
<div id="ref-Smith2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">4. </div><div class="csl-right-inline">Smith, D. G. A.; Burns, L. A.; Simmonett, A. C.; Parrish, R. M.; Schieber, M. C.; Galvelis, R.; Kraus, P.; Kruse, H.; Di Remigio, R.; Alenaizan, A.; James, A. M.; Lehtola, S.; Misiewicz, J. P.; Scheurer, M.; Shaw, R. A.; Schriber, J. B.; Xie, Y.; Glick, Z. L.; Sirianni, D. A.; O’Brien, J. S.; Waldrop, J. M.; Kumar, A.; Hohenstein, E. G.; Pritchard, B. P.; Brooks, B. R.; Schaefer III, H. F.; Sokolov, A. Yu.; Patkowski, K.; DePrince III, A. E.; Bozkaya, U.; King, R. A.; Evangelista, F. A.; Turney, J. M.; Crawford, T. D.; Sherrill, C. D. Psi4 1.4: Open-Source Software for High-Throughput Quantum Chemistry. <em>The Journal of Chemical Physics</em> <strong>2020</strong>, <em>152</em> (18), 184108. <a href="https://doi.org/10.1063/5.0006002">https://doi.org/10.1063/5.0006002</a>.</div>
</div>
<div id="ref-Conda2016" class="csl-entry" role="listitem">
<div class="csl-left-margin">5. </div><div class="csl-right-inline">Inc., A. <a href="https://docs.conda.io/en/latest/">Conda: Package and Environment Management System</a>. <em>Anaconda Documentation</em> <strong>2016</strong>.</div>
</div>
</div>
    </section>
</article>
            </div>
        </main>

        <footer>
            <div class="footer-content">
                <div>
                    Site proudly generated by
                    <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </div>
                
                <button class="print-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="6 9 6 2 18 2 18 9"></polyline>
                        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
                        <rect x="6" y="14" width="12" height="8"></rect>
                    </svg>
                    Print Article
                </button>
                
                <div>
                    © 2025
                </div>
            </div>
        </footer>
    </body>
</html>